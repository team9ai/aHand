// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: ahand/v1/envelope.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "ahand.v1";

/** Envelope wraps all messages on the wire (WS and IPC). */
export interface Envelope {
  deviceId: string;
  traceId: string;
  msgId: string;
  seq: number;
  ack: number;
  tsMs: number;
  hello?: Hello | undefined;
  jobRequest?: JobRequest | undefined;
  jobEvent?: JobEvent | undefined;
  jobFinished?: JobFinished | undefined;
  jobRejected?: JobRejected | undefined;
  cancelJob?: CancelJob | undefined;
  approvalRequest?: ApprovalRequest | undefined;
  approvalResponse?: ApprovalResponse | undefined;
  policyQuery?: PolicyQuery | undefined;
  policyState?: PolicyState | undefined;
  policyUpdate?: PolicyUpdate | undefined;
}

/** Hello - initial handshake after WS connection. */
export interface Hello {
  version: string;
  hostname: string;
  os: string;
  capabilities: string[];
  /** on reconnect, the highest seq received from peer */
  lastAck: number;
}

/** JobRequest - cloud asks local to execute a tool. */
export interface JobRequest {
  jobId: string;
  /** executable name, e.g. "rg", "git" */
  tool: string;
  args: string[];
  cwd: string;
  env: { [key: string]: string };
  timeoutMs: number;
}

export interface JobRequest_EnvEntry {
  key: string;
  value: string;
}

/** JobEvent - streaming output from a running job. */
export interface JobEvent {
  jobId: string;
  stdoutChunk?: Buffer | undefined;
  stderrChunk?:
    | Buffer
    | undefined;
  /** 0-100 */
  progress?: number | undefined;
}

/** JobFinished - job completed (success or failure). */
export interface JobFinished {
  jobId: string;
  exitCode: number;
  /** empty on success */
  error: string;
}

/** JobRejected - local policy rejected the job. */
export interface JobRejected {
  jobId: string;
  reason: string;
}

/** CancelJob - request to cancel a running job. */
export interface CancelJob {
  jobId: string;
}

/** ApprovalRequest - daemon asks user to approve a job that is not in the allowlist. */
export interface ApprovalRequest {
  jobId: string;
  tool: string;
  args: string[];
  cwd: string;
  reason: string;
  detectedDomains: string[];
  /** absolute timestamp when this request expires */
  expiresMs: number;
  /** who submitted the job (IPC="uid:N", WS="cloud") */
  callerUid: string;
}

/** ApprovalResponse - user responds to an approval request. */
export interface ApprovalResponse {
  jobId: string;
  approved: boolean;
  /** if true, remember approval for this user's session */
  remember: boolean;
}

/** PolicyQuery - request the current policy configuration. */
export interface PolicyQuery {
}

/** PolicyState - snapshot of the current policy (response to query or update). */
export interface PolicyState {
  allowedTools: string[];
  deniedTools: string[];
  deniedPaths: string[];
  allowedDomains: string[];
  approvalTimeoutSecs: number;
}

/** PolicyUpdate - incremental policy modification. Empty lists = no change. */
export interface PolicyUpdate {
  addAllowedTools: string[];
  removeAllowedTools: string[];
  addDeniedTools: string[];
  removeDeniedTools: string[];
  addAllowedDomains: string[];
  removeAllowedDomains: string[];
  addDeniedPaths: string[];
  removeDeniedPaths: string[];
  /** 0 = don't change */
  approvalTimeoutSecs: number;
}

function createBaseEnvelope(): Envelope {
  return {
    deviceId: "",
    traceId: "",
    msgId: "",
    seq: 0,
    ack: 0,
    tsMs: 0,
    hello: undefined,
    jobRequest: undefined,
    jobEvent: undefined,
    jobFinished: undefined,
    jobRejected: undefined,
    cancelJob: undefined,
    approvalRequest: undefined,
    approvalResponse: undefined,
    policyQuery: undefined,
    policyState: undefined,
    policyUpdate: undefined,
  };
}

export const Envelope: MessageFns<Envelope> = {
  encode(message: Envelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.traceId !== "") {
      writer.uint32(18).string(message.traceId);
    }
    if (message.msgId !== "") {
      writer.uint32(26).string(message.msgId);
    }
    if (message.seq !== 0) {
      writer.uint32(32).uint64(message.seq);
    }
    if (message.ack !== 0) {
      writer.uint32(40).uint64(message.ack);
    }
    if (message.tsMs !== 0) {
      writer.uint32(48).uint64(message.tsMs);
    }
    if (message.hello !== undefined) {
      Hello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.jobRequest !== undefined) {
      JobRequest.encode(message.jobRequest, writer.uint32(90).fork()).join();
    }
    if (message.jobEvent !== undefined) {
      JobEvent.encode(message.jobEvent, writer.uint32(98).fork()).join();
    }
    if (message.jobFinished !== undefined) {
      JobFinished.encode(message.jobFinished, writer.uint32(106).fork()).join();
    }
    if (message.jobRejected !== undefined) {
      JobRejected.encode(message.jobRejected, writer.uint32(114).fork()).join();
    }
    if (message.cancelJob !== undefined) {
      CancelJob.encode(message.cancelJob, writer.uint32(122).fork()).join();
    }
    if (message.approvalRequest !== undefined) {
      ApprovalRequest.encode(message.approvalRequest, writer.uint32(130).fork()).join();
    }
    if (message.approvalResponse !== undefined) {
      ApprovalResponse.encode(message.approvalResponse, writer.uint32(138).fork()).join();
    }
    if (message.policyQuery !== undefined) {
      PolicyQuery.encode(message.policyQuery, writer.uint32(146).fork()).join();
    }
    if (message.policyState !== undefined) {
      PolicyState.encode(message.policyState, writer.uint32(154).fork()).join();
    }
    if (message.policyUpdate !== undefined) {
      PolicyUpdate.encode(message.policyUpdate, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Envelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.traceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msgId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.seq = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ack = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.tsMs = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = Hello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.jobRequest = JobRequest.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.jobEvent = JobEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.jobFinished = JobFinished.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.jobRejected = JobRejected.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.cancelJob = CancelJob.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.approvalRequest = ApprovalRequest.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.approvalResponse = ApprovalResponse.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.policyQuery = PolicyQuery.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.policyState = PolicyState.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.policyUpdate = PolicyUpdate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Envelope {
    return {
      deviceId: isSet(object.deviceId)
        ? globalThis.String(object.deviceId)
        : isSet(object.device_id)
        ? globalThis.String(object.device_id)
        : "",
      traceId: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      msgId: isSet(object.msgId)
        ? globalThis.String(object.msgId)
        : isSet(object.msg_id)
        ? globalThis.String(object.msg_id)
        : "",
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      ack: isSet(object.ack) ? globalThis.Number(object.ack) : 0,
      tsMs: isSet(object.tsMs)
        ? globalThis.Number(object.tsMs)
        : isSet(object.ts_ms)
        ? globalThis.Number(object.ts_ms)
        : 0,
      hello: isSet(object.hello) ? Hello.fromJSON(object.hello) : undefined,
      jobRequest: isSet(object.jobRequest)
        ? JobRequest.fromJSON(object.jobRequest)
        : isSet(object.job_request)
        ? JobRequest.fromJSON(object.job_request)
        : undefined,
      jobEvent: isSet(object.jobEvent)
        ? JobEvent.fromJSON(object.jobEvent)
        : isSet(object.job_event)
        ? JobEvent.fromJSON(object.job_event)
        : undefined,
      jobFinished: isSet(object.jobFinished)
        ? JobFinished.fromJSON(object.jobFinished)
        : isSet(object.job_finished)
        ? JobFinished.fromJSON(object.job_finished)
        : undefined,
      jobRejected: isSet(object.jobRejected)
        ? JobRejected.fromJSON(object.jobRejected)
        : isSet(object.job_rejected)
        ? JobRejected.fromJSON(object.job_rejected)
        : undefined,
      cancelJob: isSet(object.cancelJob)
        ? CancelJob.fromJSON(object.cancelJob)
        : isSet(object.cancel_job)
        ? CancelJob.fromJSON(object.cancel_job)
        : undefined,
      approvalRequest: isSet(object.approvalRequest)
        ? ApprovalRequest.fromJSON(object.approvalRequest)
        : isSet(object.approval_request)
        ? ApprovalRequest.fromJSON(object.approval_request)
        : undefined,
      approvalResponse: isSet(object.approvalResponse)
        ? ApprovalResponse.fromJSON(object.approvalResponse)
        : isSet(object.approval_response)
        ? ApprovalResponse.fromJSON(object.approval_response)
        : undefined,
      policyQuery: isSet(object.policyQuery)
        ? PolicyQuery.fromJSON(object.policyQuery)
        : isSet(object.policy_query)
        ? PolicyQuery.fromJSON(object.policy_query)
        : undefined,
      policyState: isSet(object.policyState)
        ? PolicyState.fromJSON(object.policyState)
        : isSet(object.policy_state)
        ? PolicyState.fromJSON(object.policy_state)
        : undefined,
      policyUpdate: isSet(object.policyUpdate)
        ? PolicyUpdate.fromJSON(object.policyUpdate)
        : isSet(object.policy_update)
        ? PolicyUpdate.fromJSON(object.policy_update)
        : undefined,
    };
  },

  toJSON(message: Envelope): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.msgId !== "") {
      obj.msgId = message.msgId;
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.ack !== 0) {
      obj.ack = Math.round(message.ack);
    }
    if (message.tsMs !== 0) {
      obj.tsMs = Math.round(message.tsMs);
    }
    if (message.hello !== undefined) {
      obj.hello = Hello.toJSON(message.hello);
    }
    if (message.jobRequest !== undefined) {
      obj.jobRequest = JobRequest.toJSON(message.jobRequest);
    }
    if (message.jobEvent !== undefined) {
      obj.jobEvent = JobEvent.toJSON(message.jobEvent);
    }
    if (message.jobFinished !== undefined) {
      obj.jobFinished = JobFinished.toJSON(message.jobFinished);
    }
    if (message.jobRejected !== undefined) {
      obj.jobRejected = JobRejected.toJSON(message.jobRejected);
    }
    if (message.cancelJob !== undefined) {
      obj.cancelJob = CancelJob.toJSON(message.cancelJob);
    }
    if (message.approvalRequest !== undefined) {
      obj.approvalRequest = ApprovalRequest.toJSON(message.approvalRequest);
    }
    if (message.approvalResponse !== undefined) {
      obj.approvalResponse = ApprovalResponse.toJSON(message.approvalResponse);
    }
    if (message.policyQuery !== undefined) {
      obj.policyQuery = PolicyQuery.toJSON(message.policyQuery);
    }
    if (message.policyState !== undefined) {
      obj.policyState = PolicyState.toJSON(message.policyState);
    }
    if (message.policyUpdate !== undefined) {
      obj.policyUpdate = PolicyUpdate.toJSON(message.policyUpdate);
    }
    return obj;
  },

  create(base?: DeepPartial<Envelope>): Envelope {
    return Envelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Envelope>): Envelope {
    const message = createBaseEnvelope();
    message.deviceId = object.deviceId ?? "";
    message.traceId = object.traceId ?? "";
    message.msgId = object.msgId ?? "";
    message.seq = object.seq ?? 0;
    message.ack = object.ack ?? 0;
    message.tsMs = object.tsMs ?? 0;
    message.hello = (object.hello !== undefined && object.hello !== null) ? Hello.fromPartial(object.hello) : undefined;
    message.jobRequest = (object.jobRequest !== undefined && object.jobRequest !== null)
      ? JobRequest.fromPartial(object.jobRequest)
      : undefined;
    message.jobEvent = (object.jobEvent !== undefined && object.jobEvent !== null)
      ? JobEvent.fromPartial(object.jobEvent)
      : undefined;
    message.jobFinished = (object.jobFinished !== undefined && object.jobFinished !== null)
      ? JobFinished.fromPartial(object.jobFinished)
      : undefined;
    message.jobRejected = (object.jobRejected !== undefined && object.jobRejected !== null)
      ? JobRejected.fromPartial(object.jobRejected)
      : undefined;
    message.cancelJob = (object.cancelJob !== undefined && object.cancelJob !== null)
      ? CancelJob.fromPartial(object.cancelJob)
      : undefined;
    message.approvalRequest = (object.approvalRequest !== undefined && object.approvalRequest !== null)
      ? ApprovalRequest.fromPartial(object.approvalRequest)
      : undefined;
    message.approvalResponse = (object.approvalResponse !== undefined && object.approvalResponse !== null)
      ? ApprovalResponse.fromPartial(object.approvalResponse)
      : undefined;
    message.policyQuery = (object.policyQuery !== undefined && object.policyQuery !== null)
      ? PolicyQuery.fromPartial(object.policyQuery)
      : undefined;
    message.policyState = (object.policyState !== undefined && object.policyState !== null)
      ? PolicyState.fromPartial(object.policyState)
      : undefined;
    message.policyUpdate = (object.policyUpdate !== undefined && object.policyUpdate !== null)
      ? PolicyUpdate.fromPartial(object.policyUpdate)
      : undefined;
    return message;
  },
};

function createBaseHello(): Hello {
  return { version: "", hostname: "", os: "", capabilities: [], lastAck: 0 };
}

export const Hello: MessageFns<Hello> = {
  encode(message: Hello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    if (message.os !== "") {
      writer.uint32(26).string(message.os);
    }
    for (const v of message.capabilities) {
      writer.uint32(34).string(v!);
    }
    if (message.lastAck !== 0) {
      writer.uint32(40).uint64(message.lastAck);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.os = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastAck = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hello {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
      lastAck: isSet(object.lastAck)
        ? globalThis.Number(object.lastAck)
        : isSet(object.last_ack)
        ? globalThis.Number(object.last_ack)
        : 0,
    };
  },

  toJSON(message: Hello): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    if (message.lastAck !== 0) {
      obj.lastAck = Math.round(message.lastAck);
    }
    return obj;
  },

  create(base?: DeepPartial<Hello>): Hello {
    return Hello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hello>): Hello {
    const message = createBaseHello();
    message.version = object.version ?? "";
    message.hostname = object.hostname ?? "";
    message.os = object.os ?? "";
    message.capabilities = object.capabilities?.map((e) => e) || [];
    message.lastAck = object.lastAck ?? 0;
    return message;
  },
};

function createBaseJobRequest(): JobRequest {
  return { jobId: "", tool: "", args: [], cwd: "", env: {}, timeoutMs: 0 };
}

export const JobRequest: MessageFns<JobRequest> = {
  encode(message: JobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.tool !== "") {
      writer.uint32(18).string(message.tool);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    if (message.cwd !== "") {
      writer.uint32(34).string(message.cwd);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      JobRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.timeoutMs !== 0) {
      writer.uint32(48).uint64(message.timeoutMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tool = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = JobRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.env[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timeoutMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRequest {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      tool: isSet(object.tool) ? globalThis.String(object.tool) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      timeoutMs: isSet(object.timeoutMs)
        ? globalThis.Number(object.timeoutMs)
        : isSet(object.timeout_ms)
        ? globalThis.Number(object.timeout_ms)
        : 0,
    };
  },

  toJSON(message: JobRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.tool !== "") {
      obj.tool = message.tool;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.cwd !== "") {
      obj.cwd = message.cwd;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create(base?: DeepPartial<JobRequest>): JobRequest {
    return JobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobRequest>): JobRequest {
    const message = createBaseJobRequest();
    message.jobId = object.jobId ?? "";
    message.tool = object.tool ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.cwd = object.cwd ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseJobRequest_EnvEntry(): JobRequest_EnvEntry {
  return { key: "", value: "" };
}

export const JobRequest_EnvEntry: MessageFns<JobRequest_EnvEntry> = {
  encode(message: JobRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: JobRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<JobRequest_EnvEntry>): JobRequest_EnvEntry {
    return JobRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobRequest_EnvEntry>): JobRequest_EnvEntry {
    const message = createBaseJobRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseJobEvent(): JobEvent {
  return { jobId: "", stdoutChunk: undefined, stderrChunk: undefined, progress: undefined };
}

export const JobEvent: MessageFns<JobEvent> = {
  encode(message: JobEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.stdoutChunk !== undefined) {
      writer.uint32(18).bytes(message.stdoutChunk);
    }
    if (message.stderrChunk !== undefined) {
      writer.uint32(26).bytes(message.stderrChunk);
    }
    if (message.progress !== undefined) {
      writer.uint32(32).uint32(message.progress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stdoutChunk = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stderrChunk = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.progress = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobEvent {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      stdoutChunk: isSet(object.stdoutChunk)
        ? Buffer.from(bytesFromBase64(object.stdoutChunk))
        : isSet(object.stdout_chunk)
        ? Buffer.from(bytesFromBase64(object.stdout_chunk))
        : undefined,
      stderrChunk: isSet(object.stderrChunk)
        ? Buffer.from(bytesFromBase64(object.stderrChunk))
        : isSet(object.stderr_chunk)
        ? Buffer.from(bytesFromBase64(object.stderr_chunk))
        : undefined,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : undefined,
    };
  },

  toJSON(message: JobEvent): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.stdoutChunk !== undefined) {
      obj.stdoutChunk = base64FromBytes(message.stdoutChunk);
    }
    if (message.stderrChunk !== undefined) {
      obj.stderrChunk = base64FromBytes(message.stderrChunk);
    }
    if (message.progress !== undefined) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create(base?: DeepPartial<JobEvent>): JobEvent {
    return JobEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobEvent>): JobEvent {
    const message = createBaseJobEvent();
    message.jobId = object.jobId ?? "";
    message.stdoutChunk = object.stdoutChunk ?? undefined;
    message.stderrChunk = object.stderrChunk ?? undefined;
    message.progress = object.progress ?? undefined;
    return message;
  },
};

function createBaseJobFinished(): JobFinished {
  return { jobId: "", exitCode: 0, error: "" };
}

export const JobFinished: MessageFns<JobFinished> = {
  encode(message: JobFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobFinished {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: JobFinished): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<JobFinished>): JobFinished {
    return JobFinished.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobFinished>): JobFinished {
    const message = createBaseJobFinished();
    message.jobId = object.jobId ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseJobRejected(): JobRejected {
  return { jobId: "", reason: "" };
}

export const JobRejected: MessageFns<JobRejected> = {
  encode(message: JobRejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRejected {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: JobRejected): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<JobRejected>): JobRejected {
    return JobRejected.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobRejected>): JobRejected {
    const message = createBaseJobRejected();
    message.jobId = object.jobId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseCancelJob(): CancelJob {
  return { jobId: "" };
}

export const CancelJob: MessageFns<CancelJob> = {
  encode(message: CancelJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelJob {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
    };
  },

  toJSON(message: CancelJob): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelJob>): CancelJob {
    return CancelJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelJob>): CancelJob {
    const message = createBaseCancelJob();
    message.jobId = object.jobId ?? "";
    return message;
  },
};

function createBaseApprovalRequest(): ApprovalRequest {
  return { jobId: "", tool: "", args: [], cwd: "", reason: "", detectedDomains: [], expiresMs: 0, callerUid: "" };
}

export const ApprovalRequest: MessageFns<ApprovalRequest> = {
  encode(message: ApprovalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.tool !== "") {
      writer.uint32(18).string(message.tool);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    if (message.cwd !== "") {
      writer.uint32(34).string(message.cwd);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    for (const v of message.detectedDomains) {
      writer.uint32(50).string(v!);
    }
    if (message.expiresMs !== 0) {
      writer.uint32(56).uint64(message.expiresMs);
    }
    if (message.callerUid !== "") {
      writer.uint32(66).string(message.callerUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tool = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.detectedDomains.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expiresMs = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.callerUid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovalRequest {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      tool: isSet(object.tool) ? globalThis.String(object.tool) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      detectedDomains: globalThis.Array.isArray(object?.detectedDomains)
        ? object.detectedDomains.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.detected_domains)
        ? object.detected_domains.map((e: any) => globalThis.String(e))
        : [],
      expiresMs: isSet(object.expiresMs)
        ? globalThis.Number(object.expiresMs)
        : isSet(object.expires_ms)
        ? globalThis.Number(object.expires_ms)
        : 0,
      callerUid: isSet(object.callerUid)
        ? globalThis.String(object.callerUid)
        : isSet(object.caller_uid)
        ? globalThis.String(object.caller_uid)
        : "",
    };
  },

  toJSON(message: ApprovalRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.tool !== "") {
      obj.tool = message.tool;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.cwd !== "") {
      obj.cwd = message.cwd;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.detectedDomains?.length) {
      obj.detectedDomains = message.detectedDomains;
    }
    if (message.expiresMs !== 0) {
      obj.expiresMs = Math.round(message.expiresMs);
    }
    if (message.callerUid !== "") {
      obj.callerUid = message.callerUid;
    }
    return obj;
  },

  create(base?: DeepPartial<ApprovalRequest>): ApprovalRequest {
    return ApprovalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApprovalRequest>): ApprovalRequest {
    const message = createBaseApprovalRequest();
    message.jobId = object.jobId ?? "";
    message.tool = object.tool ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.cwd = object.cwd ?? "";
    message.reason = object.reason ?? "";
    message.detectedDomains = object.detectedDomains?.map((e) => e) || [];
    message.expiresMs = object.expiresMs ?? 0;
    message.callerUid = object.callerUid ?? "";
    return message;
  },
};

function createBaseApprovalResponse(): ApprovalResponse {
  return { jobId: "", approved: false, remember: false };
}

export const ApprovalResponse: MessageFns<ApprovalResponse> = {
  encode(message: ApprovalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.approved !== false) {
      writer.uint32(16).bool(message.approved);
    }
    if (message.remember !== false) {
      writer.uint32(24).bool(message.remember);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.remember = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovalResponse {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
      remember: isSet(object.remember) ? globalThis.Boolean(object.remember) : false,
    };
  },

  toJSON(message: ApprovalResponse): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    if (message.remember !== false) {
      obj.remember = message.remember;
    }
    return obj;
  },

  create(base?: DeepPartial<ApprovalResponse>): ApprovalResponse {
    return ApprovalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApprovalResponse>): ApprovalResponse {
    const message = createBaseApprovalResponse();
    message.jobId = object.jobId ?? "";
    message.approved = object.approved ?? false;
    message.remember = object.remember ?? false;
    return message;
  },
};

function createBasePolicyQuery(): PolicyQuery {
  return {};
}

export const PolicyQuery: MessageFns<PolicyQuery> = {
  encode(_: PolicyQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PolicyQuery {
    return {};
  },

  toJSON(_: PolicyQuery): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PolicyQuery>): PolicyQuery {
    return PolicyQuery.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PolicyQuery>): PolicyQuery {
    const message = createBasePolicyQuery();
    return message;
  },
};

function createBasePolicyState(): PolicyState {
  return { allowedTools: [], deniedTools: [], deniedPaths: [], allowedDomains: [], approvalTimeoutSecs: 0 };
}

export const PolicyState: MessageFns<PolicyState> = {
  encode(message: PolicyState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedTools) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.deniedTools) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.deniedPaths) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.allowedDomains) {
      writer.uint32(34).string(v!);
    }
    if (message.approvalTimeoutSecs !== 0) {
      writer.uint32(40).uint64(message.approvalTimeoutSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowedTools.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deniedTools.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deniedPaths.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowedDomains.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.approvalTimeoutSecs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyState {
    return {
      allowedTools: globalThis.Array.isArray(object?.allowedTools)
        ? object.allowedTools.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.allowed_tools)
        ? object.allowed_tools.map((e: any) => globalThis.String(e))
        : [],
      deniedTools: globalThis.Array.isArray(object?.deniedTools)
        ? object.deniedTools.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.denied_tools)
        ? object.denied_tools.map((e: any) => globalThis.String(e))
        : [],
      deniedPaths: globalThis.Array.isArray(object?.deniedPaths)
        ? object.deniedPaths.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.denied_paths)
        ? object.denied_paths.map((e: any) => globalThis.String(e))
        : [],
      allowedDomains: globalThis.Array.isArray(object?.allowedDomains)
        ? object.allowedDomains.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.allowed_domains)
        ? object.allowed_domains.map((e: any) => globalThis.String(e))
        : [],
      approvalTimeoutSecs: isSet(object.approvalTimeoutSecs)
        ? globalThis.Number(object.approvalTimeoutSecs)
        : isSet(object.approval_timeout_secs)
        ? globalThis.Number(object.approval_timeout_secs)
        : 0,
    };
  },

  toJSON(message: PolicyState): unknown {
    const obj: any = {};
    if (message.allowedTools?.length) {
      obj.allowedTools = message.allowedTools;
    }
    if (message.deniedTools?.length) {
      obj.deniedTools = message.deniedTools;
    }
    if (message.deniedPaths?.length) {
      obj.deniedPaths = message.deniedPaths;
    }
    if (message.allowedDomains?.length) {
      obj.allowedDomains = message.allowedDomains;
    }
    if (message.approvalTimeoutSecs !== 0) {
      obj.approvalTimeoutSecs = Math.round(message.approvalTimeoutSecs);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyState>): PolicyState {
    return PolicyState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyState>): PolicyState {
    const message = createBasePolicyState();
    message.allowedTools = object.allowedTools?.map((e) => e) || [];
    message.deniedTools = object.deniedTools?.map((e) => e) || [];
    message.deniedPaths = object.deniedPaths?.map((e) => e) || [];
    message.allowedDomains = object.allowedDomains?.map((e) => e) || [];
    message.approvalTimeoutSecs = object.approvalTimeoutSecs ?? 0;
    return message;
  },
};

function createBasePolicyUpdate(): PolicyUpdate {
  return {
    addAllowedTools: [],
    removeAllowedTools: [],
    addDeniedTools: [],
    removeDeniedTools: [],
    addAllowedDomains: [],
    removeAllowedDomains: [],
    addDeniedPaths: [],
    removeDeniedPaths: [],
    approvalTimeoutSecs: 0,
  };
}

export const PolicyUpdate: MessageFns<PolicyUpdate> = {
  encode(message: PolicyUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addAllowedTools) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.removeAllowedTools) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.addDeniedTools) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.removeDeniedTools) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.addAllowedDomains) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.removeAllowedDomains) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.addDeniedPaths) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.removeDeniedPaths) {
      writer.uint32(66).string(v!);
    }
    if (message.approvalTimeoutSecs !== 0) {
      writer.uint32(72).uint64(message.approvalTimeoutSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addAllowedTools.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removeAllowedTools.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addDeniedTools.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.removeDeniedTools.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addAllowedDomains.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.removeAllowedDomains.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.addDeniedPaths.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.removeDeniedPaths.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.approvalTimeoutSecs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyUpdate {
    return {
      addAllowedTools: globalThis.Array.isArray(object?.addAllowedTools)
        ? object.addAllowedTools.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.add_allowed_tools)
        ? object.add_allowed_tools.map((e: any) => globalThis.String(e))
        : [],
      removeAllowedTools: globalThis.Array.isArray(object?.removeAllowedTools)
        ? object.removeAllowedTools.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.remove_allowed_tools)
        ? object.remove_allowed_tools.map((e: any) => globalThis.String(e))
        : [],
      addDeniedTools: globalThis.Array.isArray(object?.addDeniedTools)
        ? object.addDeniedTools.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.add_denied_tools)
        ? object.add_denied_tools.map((e: any) => globalThis.String(e))
        : [],
      removeDeniedTools: globalThis.Array.isArray(object?.removeDeniedTools)
        ? object.removeDeniedTools.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.remove_denied_tools)
        ? object.remove_denied_tools.map((e: any) => globalThis.String(e))
        : [],
      addAllowedDomains: globalThis.Array.isArray(object?.addAllowedDomains)
        ? object.addAllowedDomains.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.add_allowed_domains)
        ? object.add_allowed_domains.map((e: any) => globalThis.String(e))
        : [],
      removeAllowedDomains: globalThis.Array.isArray(object?.removeAllowedDomains)
        ? object.removeAllowedDomains.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.remove_allowed_domains)
        ? object.remove_allowed_domains.map((e: any) => globalThis.String(e))
        : [],
      addDeniedPaths: globalThis.Array.isArray(object?.addDeniedPaths)
        ? object.addDeniedPaths.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.add_denied_paths)
        ? object.add_denied_paths.map((e: any) => globalThis.String(e))
        : [],
      removeDeniedPaths: globalThis.Array.isArray(object?.removeDeniedPaths)
        ? object.removeDeniedPaths.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.remove_denied_paths)
        ? object.remove_denied_paths.map((e: any) => globalThis.String(e))
        : [],
      approvalTimeoutSecs: isSet(object.approvalTimeoutSecs)
        ? globalThis.Number(object.approvalTimeoutSecs)
        : isSet(object.approval_timeout_secs)
        ? globalThis.Number(object.approval_timeout_secs)
        : 0,
    };
  },

  toJSON(message: PolicyUpdate): unknown {
    const obj: any = {};
    if (message.addAllowedTools?.length) {
      obj.addAllowedTools = message.addAllowedTools;
    }
    if (message.removeAllowedTools?.length) {
      obj.removeAllowedTools = message.removeAllowedTools;
    }
    if (message.addDeniedTools?.length) {
      obj.addDeniedTools = message.addDeniedTools;
    }
    if (message.removeDeniedTools?.length) {
      obj.removeDeniedTools = message.removeDeniedTools;
    }
    if (message.addAllowedDomains?.length) {
      obj.addAllowedDomains = message.addAllowedDomains;
    }
    if (message.removeAllowedDomains?.length) {
      obj.removeAllowedDomains = message.removeAllowedDomains;
    }
    if (message.addDeniedPaths?.length) {
      obj.addDeniedPaths = message.addDeniedPaths;
    }
    if (message.removeDeniedPaths?.length) {
      obj.removeDeniedPaths = message.removeDeniedPaths;
    }
    if (message.approvalTimeoutSecs !== 0) {
      obj.approvalTimeoutSecs = Math.round(message.approvalTimeoutSecs);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyUpdate>): PolicyUpdate {
    return PolicyUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyUpdate>): PolicyUpdate {
    const message = createBasePolicyUpdate();
    message.addAllowedTools = object.addAllowedTools?.map((e) => e) || [];
    message.removeAllowedTools = object.removeAllowedTools?.map((e) => e) || [];
    message.addDeniedTools = object.addDeniedTools?.map((e) => e) || [];
    message.removeDeniedTools = object.removeDeniedTools?.map((e) => e) || [];
    message.addAllowedDomains = object.addAllowedDomains?.map((e) => e) || [];
    message.removeAllowedDomains = object.removeAllowedDomains?.map((e) => e) || [];
    message.addDeniedPaths = object.addDeniedPaths?.map((e) => e) || [];
    message.removeDeniedPaths = object.removeDeniedPaths?.map((e) => e) || [];
    message.approvalTimeoutSecs = object.approvalTimeoutSecs ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
