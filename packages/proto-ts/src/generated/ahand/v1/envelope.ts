// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: ahand/v1/envelope.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "ahand.v1";

/** Envelope wraps all messages on the wire (WS and IPC). */
export interface Envelope {
  deviceId: string;
  traceId: string;
  msgId: string;
  seq: number;
  ack: number;
  tsMs: number;
  hello?: Hello | undefined;
  jobRequest?: JobRequest | undefined;
  jobEvent?: JobEvent | undefined;
  jobFinished?: JobFinished | undefined;
  jobRejected?: JobRejected | undefined;
}

/** Hello - initial handshake after WS connection. */
export interface Hello {
  version: string;
  hostname: string;
  os: string;
  capabilities: string[];
}

/** JobRequest - cloud asks local to execute a tool. */
export interface JobRequest {
  jobId: string;
  /** executable name, e.g. "rg", "git" */
  tool: string;
  args: string[];
  cwd: string;
  env: { [key: string]: string };
  timeoutMs: number;
}

export interface JobRequest_EnvEntry {
  key: string;
  value: string;
}

/** JobEvent - streaming output from a running job. */
export interface JobEvent {
  jobId: string;
  stdoutChunk?: Buffer | undefined;
  stderrChunk?:
    | Buffer
    | undefined;
  /** 0-100 */
  progress?: number | undefined;
}

/** JobFinished - job completed (success or failure). */
export interface JobFinished {
  jobId: string;
  exitCode: number;
  /** empty on success */
  error: string;
}

/** JobRejected - local policy rejected the job. */
export interface JobRejected {
  jobId: string;
  reason: string;
}

function createBaseEnvelope(): Envelope {
  return {
    deviceId: "",
    traceId: "",
    msgId: "",
    seq: 0,
    ack: 0,
    tsMs: 0,
    hello: undefined,
    jobRequest: undefined,
    jobEvent: undefined,
    jobFinished: undefined,
    jobRejected: undefined,
  };
}

export const Envelope: MessageFns<Envelope> = {
  encode(message: Envelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.traceId !== "") {
      writer.uint32(18).string(message.traceId);
    }
    if (message.msgId !== "") {
      writer.uint32(26).string(message.msgId);
    }
    if (message.seq !== 0) {
      writer.uint32(32).uint64(message.seq);
    }
    if (message.ack !== 0) {
      writer.uint32(40).uint64(message.ack);
    }
    if (message.tsMs !== 0) {
      writer.uint32(48).uint64(message.tsMs);
    }
    if (message.hello !== undefined) {
      Hello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.jobRequest !== undefined) {
      JobRequest.encode(message.jobRequest, writer.uint32(90).fork()).join();
    }
    if (message.jobEvent !== undefined) {
      JobEvent.encode(message.jobEvent, writer.uint32(98).fork()).join();
    }
    if (message.jobFinished !== undefined) {
      JobFinished.encode(message.jobFinished, writer.uint32(106).fork()).join();
    }
    if (message.jobRejected !== undefined) {
      JobRejected.encode(message.jobRejected, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Envelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.traceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msgId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.seq = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ack = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.tsMs = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = Hello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.jobRequest = JobRequest.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.jobEvent = JobEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.jobFinished = JobFinished.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.jobRejected = JobRejected.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Envelope {
    return {
      deviceId: isSet(object.deviceId)
        ? globalThis.String(object.deviceId)
        : isSet(object.device_id)
        ? globalThis.String(object.device_id)
        : "",
      traceId: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      msgId: isSet(object.msgId)
        ? globalThis.String(object.msgId)
        : isSet(object.msg_id)
        ? globalThis.String(object.msg_id)
        : "",
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      ack: isSet(object.ack) ? globalThis.Number(object.ack) : 0,
      tsMs: isSet(object.tsMs)
        ? globalThis.Number(object.tsMs)
        : isSet(object.ts_ms)
        ? globalThis.Number(object.ts_ms)
        : 0,
      hello: isSet(object.hello) ? Hello.fromJSON(object.hello) : undefined,
      jobRequest: isSet(object.jobRequest)
        ? JobRequest.fromJSON(object.jobRequest)
        : isSet(object.job_request)
        ? JobRequest.fromJSON(object.job_request)
        : undefined,
      jobEvent: isSet(object.jobEvent)
        ? JobEvent.fromJSON(object.jobEvent)
        : isSet(object.job_event)
        ? JobEvent.fromJSON(object.job_event)
        : undefined,
      jobFinished: isSet(object.jobFinished)
        ? JobFinished.fromJSON(object.jobFinished)
        : isSet(object.job_finished)
        ? JobFinished.fromJSON(object.job_finished)
        : undefined,
      jobRejected: isSet(object.jobRejected)
        ? JobRejected.fromJSON(object.jobRejected)
        : isSet(object.job_rejected)
        ? JobRejected.fromJSON(object.job_rejected)
        : undefined,
    };
  },

  toJSON(message: Envelope): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.msgId !== "") {
      obj.msgId = message.msgId;
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.ack !== 0) {
      obj.ack = Math.round(message.ack);
    }
    if (message.tsMs !== 0) {
      obj.tsMs = Math.round(message.tsMs);
    }
    if (message.hello !== undefined) {
      obj.hello = Hello.toJSON(message.hello);
    }
    if (message.jobRequest !== undefined) {
      obj.jobRequest = JobRequest.toJSON(message.jobRequest);
    }
    if (message.jobEvent !== undefined) {
      obj.jobEvent = JobEvent.toJSON(message.jobEvent);
    }
    if (message.jobFinished !== undefined) {
      obj.jobFinished = JobFinished.toJSON(message.jobFinished);
    }
    if (message.jobRejected !== undefined) {
      obj.jobRejected = JobRejected.toJSON(message.jobRejected);
    }
    return obj;
  },

  create(base?: DeepPartial<Envelope>): Envelope {
    return Envelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Envelope>): Envelope {
    const message = createBaseEnvelope();
    message.deviceId = object.deviceId ?? "";
    message.traceId = object.traceId ?? "";
    message.msgId = object.msgId ?? "";
    message.seq = object.seq ?? 0;
    message.ack = object.ack ?? 0;
    message.tsMs = object.tsMs ?? 0;
    message.hello = (object.hello !== undefined && object.hello !== null) ? Hello.fromPartial(object.hello) : undefined;
    message.jobRequest = (object.jobRequest !== undefined && object.jobRequest !== null)
      ? JobRequest.fromPartial(object.jobRequest)
      : undefined;
    message.jobEvent = (object.jobEvent !== undefined && object.jobEvent !== null)
      ? JobEvent.fromPartial(object.jobEvent)
      : undefined;
    message.jobFinished = (object.jobFinished !== undefined && object.jobFinished !== null)
      ? JobFinished.fromPartial(object.jobFinished)
      : undefined;
    message.jobRejected = (object.jobRejected !== undefined && object.jobRejected !== null)
      ? JobRejected.fromPartial(object.jobRejected)
      : undefined;
    return message;
  },
};

function createBaseHello(): Hello {
  return { version: "", hostname: "", os: "", capabilities: [] };
}

export const Hello: MessageFns<Hello> = {
  encode(message: Hello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    if (message.os !== "") {
      writer.uint32(26).string(message.os);
    }
    for (const v of message.capabilities) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.os = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hello {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Hello): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    return obj;
  },

  create(base?: DeepPartial<Hello>): Hello {
    return Hello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hello>): Hello {
    const message = createBaseHello();
    message.version = object.version ?? "";
    message.hostname = object.hostname ?? "";
    message.os = object.os ?? "";
    message.capabilities = object.capabilities?.map((e) => e) || [];
    return message;
  },
};

function createBaseJobRequest(): JobRequest {
  return { jobId: "", tool: "", args: [], cwd: "", env: {}, timeoutMs: 0 };
}

export const JobRequest: MessageFns<JobRequest> = {
  encode(message: JobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.tool !== "") {
      writer.uint32(18).string(message.tool);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    if (message.cwd !== "") {
      writer.uint32(34).string(message.cwd);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      JobRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.timeoutMs !== 0) {
      writer.uint32(48).uint64(message.timeoutMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tool = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = JobRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.env[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timeoutMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRequest {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      tool: isSet(object.tool) ? globalThis.String(object.tool) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      timeoutMs: isSet(object.timeoutMs)
        ? globalThis.Number(object.timeoutMs)
        : isSet(object.timeout_ms)
        ? globalThis.Number(object.timeout_ms)
        : 0,
    };
  },

  toJSON(message: JobRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.tool !== "") {
      obj.tool = message.tool;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.cwd !== "") {
      obj.cwd = message.cwd;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create(base?: DeepPartial<JobRequest>): JobRequest {
    return JobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobRequest>): JobRequest {
    const message = createBaseJobRequest();
    message.jobId = object.jobId ?? "";
    message.tool = object.tool ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.cwd = object.cwd ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseJobRequest_EnvEntry(): JobRequest_EnvEntry {
  return { key: "", value: "" };
}

export const JobRequest_EnvEntry: MessageFns<JobRequest_EnvEntry> = {
  encode(message: JobRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: JobRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<JobRequest_EnvEntry>): JobRequest_EnvEntry {
    return JobRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobRequest_EnvEntry>): JobRequest_EnvEntry {
    const message = createBaseJobRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseJobEvent(): JobEvent {
  return { jobId: "", stdoutChunk: undefined, stderrChunk: undefined, progress: undefined };
}

export const JobEvent: MessageFns<JobEvent> = {
  encode(message: JobEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.stdoutChunk !== undefined) {
      writer.uint32(18).bytes(message.stdoutChunk);
    }
    if (message.stderrChunk !== undefined) {
      writer.uint32(26).bytes(message.stderrChunk);
    }
    if (message.progress !== undefined) {
      writer.uint32(32).uint32(message.progress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stdoutChunk = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stderrChunk = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.progress = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobEvent {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      stdoutChunk: isSet(object.stdoutChunk)
        ? Buffer.from(bytesFromBase64(object.stdoutChunk))
        : isSet(object.stdout_chunk)
        ? Buffer.from(bytesFromBase64(object.stdout_chunk))
        : undefined,
      stderrChunk: isSet(object.stderrChunk)
        ? Buffer.from(bytesFromBase64(object.stderrChunk))
        : isSet(object.stderr_chunk)
        ? Buffer.from(bytesFromBase64(object.stderr_chunk))
        : undefined,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : undefined,
    };
  },

  toJSON(message: JobEvent): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.stdoutChunk !== undefined) {
      obj.stdoutChunk = base64FromBytes(message.stdoutChunk);
    }
    if (message.stderrChunk !== undefined) {
      obj.stderrChunk = base64FromBytes(message.stderrChunk);
    }
    if (message.progress !== undefined) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create(base?: DeepPartial<JobEvent>): JobEvent {
    return JobEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobEvent>): JobEvent {
    const message = createBaseJobEvent();
    message.jobId = object.jobId ?? "";
    message.stdoutChunk = object.stdoutChunk ?? undefined;
    message.stderrChunk = object.stderrChunk ?? undefined;
    message.progress = object.progress ?? undefined;
    return message;
  },
};

function createBaseJobFinished(): JobFinished {
  return { jobId: "", exitCode: 0, error: "" };
}

export const JobFinished: MessageFns<JobFinished> = {
  encode(message: JobFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobFinished {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: JobFinished): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<JobFinished>): JobFinished {
    return JobFinished.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobFinished>): JobFinished {
    const message = createBaseJobFinished();
    message.jobId = object.jobId ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseJobRejected(): JobRejected {
  return { jobId: "", reason: "" };
}

export const JobRejected: MessageFns<JobRejected> = {
  encode(message: JobRejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRejected {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: JobRejected): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<JobRejected>): JobRejected {
    return JobRejected.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobRejected>): JobRejected {
    const message = createBaseJobRejected();
    message.jobId = object.jobId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
